---
title: "AOC 2025: 12 Days, 12 Langs"
date: 2025-12-16T20:13:00+08:00
prev:
  text: CDDC 2025 Finals
  link: /blogs/002-cddc-2025-finals
---

[Advent of Code](https://adventofcode.com) is a yearly series of daily
programming puzzles released on December 1st. The past few years featured 25
unique puzzles, but this year it was reduced to 12. I took this as an
opportunity to use a new language every day, and I wanted each language to be
unique enough (so no mixing C and C++). These were the languages I ended up
using, ordered by the day I used them, the languages in italics indicate that I
used them for the first time.

1. [_Uiua_](#day-1-uiua)
2. [Chez Scheme](#day-2-chez-scheme)
3. [C](#day-3-c)
4. [_Rust_](#day-4-rust)
5. [_Zig_](#day-5-zig)
6. [_Elixir_](#day-6-elixir)
7. [_Go_](#day-7-go)
8. [OCaml](#day-8-ocaml)
9. [Java](#day-9-java)
10. [Python](#day-10-python)
11. [JavaScript](#day-11-javascript)
12. [JLox](#day-12-jlox)

For most of the days, I would solve it in Python first before porting my
solution to another language. I also solved some other days in Uiua, as I found
it to be a very fun language to work with. My solutions are contained in this
[GitHub repo](https://github.com/mug1wara26/AOC2025), this blog post just goes
through more of my thought process for each day.

Here is a summarised execution time for each day, day 2 was omitted because it
had a mean execution time of 4.8 seconds.

![Image](data:image/png;base64,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AAAAAADAVUoU2hMTEzVo0CDVrl1biYmJf7iuxWLRqFGj3FIcAAAAAAC+rMShvUuXLoR2AAAAAAC8qESh/epnr/McdgAAAAAAvMPlG9ElJibq5MmTxS47duyYZs2aVeaiAAAAAABAKUL7kiVLfje079+/Xxs2bChzUQAAAAAAoITT4++//37t379fkuR0OjV48ODfXbd58+buqQwAAAAAAB9XotD+3HPP6b333pPT6dSSJUs0YMAARUREFFrHarUqJCRE3bt390ihAAAAAAD4mhKF9uuvv16jR4+WdPnu8Fce/wYAAAAAADynRKH9alfCOwAAAAAA8CyXQ3tUVJQsFssfrnPw4MFSFwQAAAAAAC5zObSPGjWqSGg/f/689u3bp59//lkTJ050W3EAAAAAAPgyl0P7448//rvLJk+erO+++04DBgwoU1EAAAAAAKAUz2n/I/369VNSUpI7NwkAAAAAgM9ya2j/+eefdenSJZe+x+FwaNGiRercubNatWqlESNGKDU1tUTfu3nzZjVp0kTHjh0rTbkAAAAAAJiay9PjExMTi4w5HA6lpaUpKSlJt99+u0vbW7p0qdatW6e5c+cqIiJC8fHxio2N1ZYtWxQQEPC733f8+HHNmjXL1fIBAAAAACg33BLaJSk4OFh33XWXpk6dWuJt5efna9WqVZo4caK6du0qSUpISFDnzp21bds29e7du9jvczgcmjRpkm666SZ9+eWXrh4CAAAAAADlgsuhPTk52W07T05O1vnz59WhQ4eCsZCQEDVt2lS7d+/+3dD+0ksv6eLFixo9ejShHQAAAABQYbkc2iVp7969+vLLLzVq1ChJ0oEDB7R8+XKNGDFCzZo1K/F20tLSJEl16tQpNB4eHl6w7Le++eYbrVq1Sm+88YZOnjxZmvKL5efn1sv7AQBXsdl4j/0tegLAFbxnFI++wBe4HNp37NihUaNGqXnz5gWh3WKx6KefftIDDzygVatWqV27diXaVm5uriQVuXY9MDBQWVlZRdbPycnRxIkTNXHiRDVo0MBtod1qtahGjSpu2RYAACURElLJ6BIAoNzjvRS+wOXQvnjxYvXq1Utz584tGLvxxhv19ttva8qUKXrhhRe0bt26Em0rKChI0uVr26/8W5Ly8vJUqVLRH8DnnntODRs21P333+9q2X/I4XAqOzvHrdsEAPwfm83K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x44d05133qk5c+aof//+kqTTp0/rmWee0SeffKLAwED16NFDU6dOVWBgoJGHAQAAAACA2xke2gEAAAAAQPEMvaYdAAAAAAD8PkI7AAAAAAAmRWgHAAAAAMCkCO0AAAAAAJgUoR0AAAAAAJMitAMAAAAAYFJ+RhfgC+644w4dP3684Gt/f3/VrFlTt912m8aMGaPQ0FCv1HH06FHdd9992rp1q+rWreuVfXqC0f1cs2aN1qxZoxMnTqh+/fp65JFHNGDAAI/u09OM7ukVTqdTsbGxys/P15o1a7yyT08wup8PP/ywPv/880Jj7du3p6dlcOTIEc2ZM0e7d+9W5cqVdffdd2vSpEmqVKmSR/frKUb287f7vtratWsVHR3tsX17ktGv0c8//1wLFy5USkqKatasqSFDhmj48OEe3acnGd3Pt99+WytWrFBqaqpuuOEGjR07Vh07dvToPt3N6B5e8XufP/Py8jR37ly99957unDhgu644w49+eSTXqurNMzeU0lyOBx69NFH1bJlSz3++ONeqae0zN7PEydOKD4+Xrt27VJ+fr5atGihJ554QjfccINX6irECY+7/fbbnXPnznWmp6c709PTnT///LNz+/btzrvvvtt5zz33OLOzsz1ew3/+8x/nHXfc4WzcuLEzNTXV4/vzJCP7uX79emeLFi2cmzdvdv7888/Of/7zn84bb7zR+cEHH3hsn95ghteo0+l0rl692tm4cWNnTEyMV/bnKUb3s0OHDs5169YV7D89Pd155swZj+7T04zsaUZGhvPWW291jhw50vnDDz84P/vsM2enTp2cTz/9tMf26WlG9vP06dOFXpvHjh1zdu/e3fnggw86L1686LH9epqRPU1JSXE2a9bMuXjxYufPP//sfOedd5wtWrRwrl271mP79DQj+7llyxZnkyZNnEuXLnX++OOPzrVr1zqbN2/u/PLLLz22T08w+neR0/nHnz+feOIJ51133eXcvXu3c//+/c6+ffs6//SnP3m8prIwe0/z8vKcU6ZMcTZu3Ni5aNEij9dSVmbuZ15enrN3797OmJgY5zfffOM8fPiw8/HHH3d26NDBefr0aY/X9VtMj/eSypUrq1atWqpVq5bq1aunO++8U6tWrdKJEye0YsUKj+57+fLlGjhwoKpVq+bR/XiTUf08e/asJkyYoHvvvVf16tXT//t//0+NGzfWZ5995rF9eouRr1FJOnTokJYsWaJWrVp5fF/eYFQ/T58+rdOnT6tly5YF+69Vq5aqV6/usX16i1E9Xbt2rfz8/JSQkKDrr79et956q+Li4vTNN9/I6XR6bL+eZlQ/Q0NDC702165dq+zsbCUkJMjPr3xPADSqpzt37lTlypU1evRo1atXTz179lTnzp31ySefeGyf3mBUP1955RXdc889GjlypBo2bKg//elP6tOnjxITEz22T08x6+fPkydP6q233tL06dPVrl07tWjRQi+88IJ2796tr7/+2qN1lZVZe7pv3z71799fe/bsUUhIiEfrcCez9nPPnj06fPiwFixYoObNm+uGG25QfHy8cnJy9NFHH3m0ruIQ2g10zTXXqFu3bnrnnXcKxg4fPqw///nPio6OVrNmzQpeuJKUkZGhZs2a6a233iq0nYULF/7h9Ozt27drzpw5mjJlikeOwyy80c/Y2Fg9+OCDkqSLFy8qKSlJKSkp5W7KXEl56zWal5eniRMnKi4uTg0bNvTIsZiBN/p56NAhWSyWCt3Hq3mjp59++qm6deumwMDAgrFBgwbpzTfflMVicf9BGchbP/NX/Oc//9Grr76qJ554wtRTYsvCGz0NCwtTZmamtm7dKqfTqUOHDmnv3r1q2bKlx47LKN7o59GjR9WuXbtCYzfeeKO+/vprXbp0yb0HZAAzfP7cu3evJOmWW24pGGvYsKFq166t3bt3l+XwDGGGnu7YsUOdO3fWW2+9papVq7rnwAxihn7ecMMNevnll1W7du2CMav1cnTOzs4uy+GVCqHdYI0bN1ZqaqrOnz+v3NxcPfLII6pevbrWr1+vrVu3qkePHpo3b54OHjyo0NBQde3atdAL0uFwaPPmzerfv//v7mPDhg3q0aOHF47GeN7op3T5r28tWrTQuHHjdO+99+rOO+/08JEZxxs9jY+PV3h4uGJiYrxwRMbydD8PHz6sqlWratasWerSpYt69OihF198Ufn5+V46Qu/zdE+PHDmi8PBwzZkzR127dlW3bt00f/585eXleekIvctb76OStGjRIjVu3Fj33XefB4/IeJ7u6T333KNBgwZp0qRJuummm9SnTx917NhRjz32mJeO0Ls83c/w8HD98ssvhcaOHz+uixcvGvJh3ROM/vx58uRJ1ahRo9AfQ6XLvU9LS3PLMXqb0T0dN26cpkyZouDgYHcfmiGM7metWrV02223FRpbs2aNLly4YMjJOkK7wa5MXzl37pxyc3P14IMPasaMGWrUqJEaNGiguLg4SZfPnknSgAEDtGvXLp08eVKS9MUXXygjI0O9e/c25gBMxlv9bNiwoTZt2qTnnntO7777rhYsWODBozKWp3u6c+dObdmyRbNnz65wZy2L4+l+Hj58WHl5eWrRooVWrFihkSNHasOGDZo+fboXjs4Ynu7puXPn9MorrygvL0+JiYmaNGmStmzZUmF76q330dTUVH3wwQcaOXKkB4/GHDzd09OnT+v48eOKi4vTG2+8oeeff147duzQ4sWLvXB03ufpfvbp00fr1q3TJ598Irvdri+//FIbN26UdHmWXUVg9OfP3NxcBQQEFBkPDAwst38QNbqnFY3Z+vnBBx9o4cKFGjZsmJo0aeKWbbqifF88VgGcPXtWkhQcHKwqVarogQce0NatW3XgwAH9/PPPSk5OlnT5r0WS1KVLF4WFhentt9/Wo48+qk2bNunOO++sUNerl4W3+hkWFqawsDBFRUUpIyNDiYmJGjNmTLG/gMo7T/Y0IyND06ZN08yZMwtNP6rIPP0anTVrlqZMmVKwvHHjxvL399e4ceM0efJk1axZ0wtH6V2e7qmfn58aNmyomTNnSpKaNWsmu92usWPH6oknnlBYWJjnD9KLvPU+unnzZoWFhemuu+7y7AGZgKd7+uSTT6pOnToFfwBp2rSpnE6nZs6cqZiYmAp36YGn+/noo4/qzJkzGjlypOx2u66//nqNGDFC8fHx5X7a8RVGf/4MCgoqdgZYXl5euX0qh9E9rWjM1M/XXntNzz77rPr06aPJkyeXeXulwZl2g33//fdq0KCBqlSpolOnTqlPnz7asGGDateurQceeECbNm0qtL7NZlPfvn21ZcsW5eTkaPv27erXr59B1ZuPp/u5c+dO/ec//yk01qRJE+Xn5yszM9MTh2Q4T/Z0x44dOnXqlKZNm6bWrVurdevW2rJli/bs2aPWrVsXmZ5YEXj6Nern51fkF9SVR5OU1ymH/4unexoREVHk8S5Xvv69R5eVZ976vbR9+3b16tWr4BrBiszTPd27d6+aN29eaKxVq1a6dOmSjh075pFjMpKn+xkQEKCnnnpK+/bt044dO7RlyxZVqlRJNWvWVOXKlT19eF5h9OfPiIgIZWZmFgnu6enp5faP+Eb3tKIxSz/j4+M1c+ZMPfjgg5ozZ45hv7M4026gtLQ0ffjhhxoxYoQkaevWrcrMzNT7778vf39/Sf835ePqOxQPGDBAr7zyitasWaOqVauqU6dO3i/ehLzRzxdffFENGjTQCy+8UDC2f/9+Va9evUKewfR0T7t166Y2bdoUGluwYIHS0tK0YMEChYeHe+KwDOON1+jQoUNVt25dzZkzp2Ds22+/lb+/vxo0aOCBozKWN3oaHR1dcKf4K5dwHD58WDabrcjzccs7b/1eOnfunA4ePKixY8d65kBMxBs9rV27dsE2rrhyU8prr73W3YdkKG/0MyEhQUFBQRo5cmTB76Ft27ZVmJvOmuHzZ9u2beVwOLR371516NBB0uX7h5w8eVLR0dGl3q5RzNDTisQs/YyPj9eKFSs0ZcoUPfLII2XaVlkR2r0kJydHp06dkiRduHBBhw4d0osvvqi6devq4YcflnT5r465ubl677331LZtW/34448FH7yv/ktkw4YN1aZNGy1dulRDhw6VzWbz/gEZzKh+xsbGavz48WrTpo06d+6sXbt2aeXKlZo8eXK5P1tkRE+Dg4OL3DClSpUqCgoKKvcfNI16jd59992aPXu2WrRooU6dOunbb7/V/PnzNXz48HJ/cxqjejp8+HD1799fTz/9tB5++GEdO3ZM8+bN03333Veupx0b+XspOTlZTqdTUVFRHjo6YxjV04cfflizZs3Sddddp9tvv12HDh3S3Llz9cADD5TrqbZG9bNevXp6/vnnFRUVpeuvv16vvvqqvvnmm4Lr2ssTs37+rF27tnr16qXp06dr9uzZqlSpkp5++mm1b9/e9I9+NWtPyyuz9nPXrl1asWKFhg4dqnvvvbegRunyY+qqVKlS6m2XBqHdS1atWlXwWAJ/f3/VqVNHPXv21COPPFLwn96jRw99//33mjt3rs6dO6fIyEgNGjRIH374ob799lsNGTKkYHv9+/fXvn37fHYajVH97Nmzpy5evKhXXnlF8+bN0zXXXKOnnnpKgwYN8tzBegmvUfcyqp8xMTGyWCxas2aNZs+erVq1amnYsGF69NFHPXewXmJUT6+77jq9+uqrmj9/vu677z5VrVpVffr00bhx4zx3sF5g5M98enq6JKl69eruPzADGdXTwYMHKzAwUKtXr9YLL7xQMH30ylmq8sqofg4cOFCnT5/WM888o6ysLDVr1kx///vfdd1113nuYD3EzL/bn332Wc2ePVujR4+WdPma5PJwg08z97Q8Mms/t27dKunyHePXrFlTaNno0aP1+OOPl2n7rrI4r55TgHJj8eLF+vzzz/Xaa68ZXUqFQD/dj566F/10P3rqXvTT/eipe9HPsqOH7kdP3aui9pMz7eXM3r17deTIEb366quaNWuW0eWUe/TT/eipe9FP96On7kU/3Y+euhf9LDt66H701L0qej8J7eXMxx9/rLVr12rAgAG65557jC6n3KOf7kdP3Yt+uh89dS/66X701L3oZ9nRQ/ejp+5V0fvJ9HgAAAAAAEyqfN/uGgAAAACACozQDgAAAACASRHaAQAAAAAwKUI7AAAAAAAmRWgHAAAAAMCkCO0AAAAAAJgUoR0AAAAAAJMitAMAAAAAYFKEdgAAAAAATOr/Aw0lFD9W8WncAAAAAElFTkSuQmCC)

## Day 1: Uiua

Execution time: 276ms

From [Uiua's website](https://www.uiua.org/):

> Uiua (wee-wuh) is a general purpose array-oriented programming language with a
> focus on simplicity, beauty, and tacit code.

I first heard of Uiua 2 months ago when I was browsing
[Code Golf Stack Exchange](https://codegolf.stackexchange.com/) and saw a really
short solution that was made up of incomprehensible glyphs. It instantly got me
hooked on the language, and I felt it was easy to pick up with some functional
programming experience and I also found the
[Uiua Language Tour](https://www.uiua.org/tour) to be really well made and easy
to follow.

My solution for both parts is just 109 bytes, you may view it on
[the interactive editor](https://www.uiua.org/pad?src=0_18_0-dev_3__eJw9jTsKwkAYhPs9RUghu2yRfwvLSB6tNzAWNpYWegIJrGTT2JiHBHR7IZZ2gVh6izmJbBDLb4b5Zrbdbw6-8hkeV5KrOa3fNUyLwvJPh-Mw9iqMltCtGp-orIB5uQ7lBbr5Zx0qOzX3KNux2IM-e6gHRSRZMlEgQ8pilv7AOQI5zUMSMUzOUVhn0c3Yq0wKxxyVlThZ3Dq-ICHcpWAweeol7AuWpFll):

```uiua
&fras"1"
⬚0+[50]×⊙≡(˜ⁿ¯1=@L↙1°□)⊸≡(⋕↘1°□)⊜□⊸≠@\n
A←◿100+
B←/+=0\A
C←/+≡(/+°□=0)A⊃(≡□↘¯1\+)(≡(□+⇡⟜(>0))↘1)
⊃C B
```

It can be optimized a lot, but since this was my first time using the language,
there were a lot of idioms I was unfamiliar with. It first processes the puzzle
input into numbers, so `R30` becomes `30` and `L50` becomes `-50`, `50` is also
prepended to the array. For the first part, I just scanned through the array and
found all the spots where the dial would hit 0, using a `scan` with `add`. For
the second part, I used a really inefficient method, where I generate the range
of numbers seen by each turn of the dial, and count all the numbers that are
congruent to 0 modulo 100.

## Day 2: Chez Scheme

Execution time: 4.87s

I love S-Expressions.

In contrast with yesterday's solution, today's solution is 76 lines long, as I
had to write helper functions to split strings and numbers.

```scheme
(define (split-string s delim)
  (letrec ([run
    (lambda (xs curr acc)
      (if (null? xs)
        (reverse (cons (list->string (reverse curr)) acc))
        (if (equal? (car xs) delim)
          (run (cdr xs) '() (cons (list->string (reverse curr)) acc))
          (run (cdr xs) (cons (car xs) curr) acc))))
  ]) (run (string->list s) '() '())))

(display "enter your puzzle input: ")
(define puzzle (get-line (current-input-port)))

(define parsed (map (lambda (s) (map string->number (split-string s #\-))) (split-string puzzle #\,)))

;; inclusive end
(define (range start end)
  (map (lambda (x) (+ x start)) (iota (- end start -1))))

(define (log10 n)
  (/ (log n) (log 10)))

(define (num-digits n)
  (inexact->exact (floor (1+ (log10 n)))))

(define (split-num n)
  (let [(delim (expt 10 (/ (num-digits n) 2)))]
    (cons (floor (/ n delim)) (mod n delim))))

(define (invalid n)
  (if (odd? (num-digits n))
    #f
    (let [(x (split-num n))]
      (= (car x) (cdr x)))))


;; x is number of digits in each split
(define (split-num2 n x)
  (letrec [(run (lambda (n acc)
    (if (<= (num-digits n) x)
      (cons n acc)
      (let [(delim (expt 10 x))]
        (run (floor (/ n delim)) (cons (mod n delim) acc))
      ))
  ))] (run n '())))

(define (invalid2 n)
  (letrec [(num (num-digits n)) (run (lambda (x)
    (if (= x 0)
      #f
      (if (and (zero? (mod num x)) (apply = (split-num2 n x)))
        #t
        (run (1- x))
      )
    )
  ))] (run (1- (num-digits n))))
)

(define (sol parsed invalid)
  (fold-left
    (lambda (x y)
      (+ x (fold-left
        (lambda (x y)
          (if (invalid y)
            (+ x y)
            x))
        0
        (apply range y))))
    0
    parsed))

(display (sol parsed invalid))

(newline)

(display (sol parsed invalid2))
```

It's just a simple brute force, I did have to spend a short while debugging my
part 2, because one of my functions wasn't tail-recursive and it ended up
hanging my laptop, but after fixing that it spits out the solution in 5 seconds.

## Day 3: C

Execution time: 12.6ms

For day 3, I solved it first in C using a typical DP solution. Then I solved it
again in Uiua using a greedy approach.

```c
#include <stdio.h>
#include <math.h>

long long getDigit(char line[100], int i) {
  return line[i] - 48;
}

long long sol(char line[100], int n) {
  // let dp[i][n] denote the max joltage only considering index i onwards, with n digits
  long long dp[100][n + 1];

  dp[99][0] = 0;
  dp[99][1] = getDigit(line, 99);
  for (int i = 1; i < 100; i++) {
    for (int j = 0; j < n + 1; j++) {
      if (j == i+1) {
        dp[99 - i][j] = dp[99 - i + 1][j - 1] + getDigit(line, 99 - i) * pow(10, j - 1);
        break;
      }
      if (j)
        dp[99 - i][j] = fmax(dp[99 - i + 1][j], dp[99 - i + 1][j - 1] + getDigit(line, 99 - i) * pow(10, j - 1));
      else
        dp[99 - i][0] = 0;
    }
  }

  return dp[0][n];
}

int main() {
  FILE *fptr = fopen("3", "r");

  char line[100];
  int part1 = 0;
  long long part2 = 0;

  while (fscanf(fptr, "%s", line) == 1) {
    part1 += sol(line, 2);
    part2 += sol(line, 12);
  }

  printf("Part 1: %d\n", part1);
  printf("Part 2: %lli", part2);
}
```

I'm honestly not sure why I used DP here, I initially solved part 1 with the
greedy approach, I guess I just didn't realise it generalises to any digit
number. The greedy solution is still faster by a constant factor and takes less
memory.

You may view my solution on
[the interactive editor](https://www.uiua.org/pad?src=0_18_0-dev_3__JmZyYXMiMyIK4oqc4oiY4oq44omgQFxuCkEg4oaQIC8r4omhKOKLleKJoeKKoeKKmcKkLTHihpgx4oq4y5xcKCsrMeKKmSjiiqLijZbLnOKGmCnin5zihpgpKcKk4oqCWzBdKzHih4zih6HCrwriioMoQTEyfEEyKQo=).

```uiua
&fras"3"
⊜∘⊸≠@\n
A←/+≡(⋕≡⊡⊙¤-1↘1⊸˜\(++1⊙(⊢⍖˜↘)⟜↘))¤⊂[0]+1⇌⇡¯
⊃(A12|A2)
```

We basically just find the index of the max character from \[0:-11\], lets call
this index `n`. Then we find the index of the max character from \[n:-10\], and
keep repeating this procedure until we get all 12 characters. Uiua has a handy
function called [`fall`](https://www.uiua.org/docs/fall) that returns the
indices of the list if its elements were sorted in descending order, while this
is `O(n log n)`, if we use the [`first`](https://www.uiua.org/docs/first)
function to only get the max index, the Uiua interpreter optimizes it to `O(n)`.

## Day 4: Rust

Execution time: 37.3ms

I originally solved today's solution with a simple brute force in Python because
I was busy. After getting home past midnight, I decided I did not want to waste
Python on such an easy day, so I learnt Rust and wrote a more efficient
solution.

```rust
use std::fs;

fn get_surrounding_rolls(contents: &[Vec<u8>], row: usize, col: usize) -> Vec<(usize, usize)> {
    let height = contents.len();
    let width = contents[0].len();

    let row_start = row.saturating_sub(1);
    let row_end = (row + 2).min(height);
    let col_start = col.saturating_sub(1);
    let col_end = (col + 2).min(width);

    contents[row_start..row_end]
        .iter()
        .enumerate()
        .flat_map(|(i, r)| {
            r[col_start..col_end]
                .iter()
                .enumerate()
                .filter(move |&(j, &cell)| {
                    cell == b'@' && (row_start + i, col_start + j) != (row, col)
                })
                .map(move |(j, _)| (row_start + i, col_start + j))
        })
        .collect()
}

fn main() {
    let binding = fs::read_to_string("4").expect("read the file");
    let mut contents: Vec<Vec<u8>> = binding.lines().map(|s| s.as_bytes().to_vec()).collect();

    let height = contents.len();
    let width = contents[0].len();

    let mut indices = Vec::new();
    for row in 0..height {
        for col in 0..width {
            if contents[row][col] == b'@' && get_surrounding_rolls(&contents, row, col).len() < 4 {
                indices.push((row, col));
                contents[row][col] = b'.';
            }
        }
    }

    let mut total = indices.len();

    println!("Part 1: {}", total);

    while !indices.is_empty() {
        let mut temp = Vec::new();
        for (r, c) in indices {
            for (row, col) in get_surrounding_rolls(&contents, r, c) {
                if get_surrounding_rolls(&contents, row, col).len() < 4 {
                    temp.push((row, col));
                    contents[row][col] = b'.';
                }
            }
        }

        total += temp.len();
        indices = temp;
    }

    println!("Part 2: {}", total);
}
```

The key idea is that after solving part 1, you just need to keep track of the
rolls that got removed, and keep repeating part 1 until no rolls can be removed.
It took a bit of fighting with the borrow checker, but I'm quite happy with my
solution. I had a good first experience with Rust and I'm looking forward to
using it for other bigger projects (probably for a compiler).

## Day 5: Zig

Execution time: 17.3ms

```zig
const std = @import("std");
const fs = std.fs;
const twople = struct { start: i64, end: i64, };
const ArrayList = std.ArrayList;

fn compareTwople(_: void, a: twople, b: twople) bool {
    return a.start < b.start;
}

pub fn main() !void {
    const file = try fs.cwd().openFile("5", .{});
    const reader = file.reader().any();

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var buf: [1024]u8 = undefined;
    var ranges = ArrayList(twople).init(allocator);
    defer ranges.deinit();
    var ids = ArrayList(i64).init(allocator);
    defer ids.deinit();

    while (try reader.readUntilDelimiterOrEof(buf[0..], '\n')) |line| {
        if (line.len == 0) {
            break;
        }
        var it = std.mem.splitScalar(u8, line, '-');
        const range = twople{ .start = try std.fmt.parseInt(i64, it.next() orelse "" , 10), .end = try std.fmt.parseInt(i64, it.next() orelse "", 10) };
        try ranges.append(range);
    }

    while (try reader.readUntilDelimiterOrEof(buf[0..], '\n')) |line| {
        try ids.append(try std.fmt.parseInt(i64, line, 10));
    }

    std.mem.sort(twople, ranges.items, {}, compareTwople);

    var i: usize = 0;

    while (i < ranges.items.len - 1) {
        const curr_range = ranges.items[i];
        const next_range = ranges.items[i+1];

        if (next_range.start <= curr_range.end + 1) {
            if (next_range.end > curr_range.end) {
                ranges.items[i] = twople { .start = curr_range.start, .end = next_range.end};
            }
            _ = ranges.orderedRemove(i+1);
        }
        else {
            i += 1;
        }
    }

    var part1: i16 = 0;

    for (ids.items) |id| {
        for (ranges.items) |r| {
            if (r.start <= id and id <= r.end) {
                part1 += 1;
                break;
            }
        }
    }


    var part2: i64 = 0;
    for (ranges.items) |r| {
        part2 += r.end - r.start + 1;
    }

    std.debug.print("{d}\n", .{part1});
    std.debug.print("{d}\n", .{part2});

}
```

There's nothing much to say here, it is basically just the
[merge intervals](https://leetcode.com/problems/merge-intervals/) leetcode
problem.

## Day 6: Elixir

Execution time: 624ms (Part 2 only)

Today, I initially solved with Python, then solved part 2 with Uiua and Elixir
because part 1 is pretty boring... that counts right?

View my Uiua code
[on the iteractive editor](https://www.uiua.org/pad?src=0_18_0-dev_3__JmZyYXMiNiIK4oqc4oiY4oq44omgQFxuCuKfnCjiipziiqLiirjiiaBAIOKKoykK4o2J4oaYwq8xCuKKnCjilqHii5Up4oq4KOKJoDDiiaEvK-KJoEAgKQovK8uc4omh4peHKOKorC8rL8OX4oqiPUAqKQo=).

```uiua
&fras"6"
⊜∘⊸≠@\n
⟜(⊜⊢⊸≠@ ⊣)
⍉↘¯1
⊜(□⋕)⊸(≠0≡/+≠@ )
/+˜≡◇(⨬/+/×⊢=@*)
```

I wrote a full explanation for how it works, but I feel like it is far too
lengthy to be contained in this blog post, curious readers can refer to the
explanation on
[the GitHub](https://github.com/mug1wara26/AOC2025/tree/master/day6)

Here is my part 2 Elixir code:

```elixir
{:ok, file} = File.read("6")
inputs = String.split(file, "\n")
nums = Enum.map(Enum.slice(inputs, 0..3), fn x -> String.graphemes(x) end)
zipped = Enum.zip_with(nums, fn [w, x, y, z] -> [w, x, y, z] end)
ops = String.split(Enum.at(inputs, 4))

defmodule Part2 do
  def solve([], [], acc) do
    acc
  end

  def solve([nums | rest_nums], [op | rest_ops], acc) do
    if op == "*" do
      solve(rest_nums, rest_ops, acc + Enum.reduce(nums, fn x, y -> x * y end))
    else
      solve(rest_nums, rest_ops, acc + Enum.sum(nums))
    end
  end

  def parse([], acc) do
    Enum.reverse(acc)
  end

  def parse([head | tail], [acc_head | acc_tail]) do
    if head == [" ", " ", " ", " "] do
      parse(tail, [[] | [acc_head | acc_tail]])
    else
      parsed = String.to_integer(String.trim(List.to_string(head)))
      parse(tail, [[parsed | acc_head] | acc_tail])
    end
  end

  def parse(nums) do
    parse(nums, [[]])
  end
end

IO.puts(Part2.solve(Part2.parse(zipped), ops, 0))
```

## Day 7: Go

Execution time: 4.38ms

Day 7 was super easy, my Go solution was pretty much just a port of my Python
solution.

```go
package main

import (
  "bufio"
  "fmt"
  "os"
  "strings"
)

func main() {
  filePath := "7"

  file, _ := os.Open(filePath)
  defer file.Close()

  scanner := bufio.NewScanner(file)

  scanner.Scan()
  line := scanner.Text()

  beams := make([]int, len(line))
  beams[strings.IndexByte(line, 'S')] = 1
  part1 := 0

  for scanner.Scan() {
    line := scanner.Text()
    new_beams := make([]int, len(line))

    for i, r := range line {
      if r == '^' {
        if beams[i] != 0 {
          new_beams[i-1] += beams[i]
          new_beams[i+1] += beams[i]
          part1 += 1
        }
      } else {
        new_beams[i] += beams[i]
      }
    }

    beams = new_beams
  }

  part2 := 0

  for _, n := range beams {
    part2 += n
  }

  fmt.Println(part1)
  fmt.Println(part2)
}
```

I solved it again in Uiua, and it is my shortest solution yet, when golfed it is
just 59 bytes! The solution method also slightly differs, as I iterate through
the input, I keep track of the number of beams in each column. For each row in
the input, I mask the beams the hit a splitter, apply a rotate left and right to
simulate them splitting, and add them up together with the beams that did not
hit the splitters. At the end of the iteration I can just do a `reduce add`.

View my Uiua code
[on the interactive editor](https://www.uiua.org/pad?src=0_18_0-dev_3__eJx1j7FqwlAUhvf7FD8GSkNaTKZOgtChq9C1FK7m2AT0Ru49YoUsTUFipm5acHDrUmjHgpuOvsV5khK14NLhDIeP_z_fCdVF32rXuGkoqVZSLqX6kfm6_WDgoaOtI3SnMDTBIDWkWu377bdUBQAPPUuaCdpaPUXWR-hAzz0aMfqZhWNtWe1XUr1LuVQdbVmKF8jsDUEzkPk63C3g4TYbG4YZD7tk65Iu6aEDJ5qRpAw3GqTMZJ3ycEf8L75SHmzGtU8EbeK_5TqqiY5jcPZEnJDFJOXkvGeYOnd25yhaHEUDqV4vDzPbRLnMNtuvyN8t8t1i--krKT8O8BTJTz_6rfajr5qB-gU_UImH).

```uiua
0
&fras"7"
⊜∘⊸≠@\n # Parse by new line
=@S°⊂   # create array of 0s except for start
˜⊙∘
Part₁ ← +/+≠0× # Count number of beams that hit splitters
# Get beams that hit splitters,
# rotate 1 and rotate -1,
# add together with beams that miss splitters
Part₂ ← ++⊃(⊃(↻1|↻¯1)×|×¬)
∧(⊃(Part₂|Part₁)=@^)
/+
```

## Day 8: OCaml

Execution time: 249ms

My favourite day so far, probably cause its the hardest so far. The
implementation is quite simple, stick all pair combinations in a heap, where the
priority is the euclidean distance between the two points, then use a UFDS
(Union Find Disjoin Set) to efficiently track the circuits. Luckily OCaml added
priority queues to the standard library about 2 months ago, but there's no UFDS
so I implemented my own.

UFDS:

```ocaml
type 'a t = {
  parent : ('a, 'a) Hashtbl.t;
  rank : ('a, int) Hashtbl.t ;
}

let create (n : int) : 'a t = {
  parent = Hashtbl.create n;
  rank = Hashtbl.create n;
}

let rec find ds x = match Hashtbl.find_opt ds.parent x with
  | Some parent ->
      if parent = x then parent
      else begin
        let parent = find ds parent in
        Hashtbl.replace ds.parent x parent;
        parent
      end;
  | None -> (
      Hashtbl.add ds.parent x x;
      Hashtbl.add ds.rank x 0;
      x
    )

let union ds a b =
  let a = find ds a in
  let b = find ds b in
  if a <> b then
    let a_rank = Hashtbl.find ds.rank a in
    let b_rank = Hashtbl.find ds.rank b in
    if a_rank < b_rank then
      Hashtbl.replace ds.parent a b
    else begin
      Hashtbl.replace ds.parent b a;
      if a_rank = b_rank then Hashtbl.replace ds.rank a (a_rank + 1)
    end
```

Main solution:

```ocaml
open Day8

module Prio : Pqueue.OrderedType with type t = int = struct
  type t = int
  let compare = compare
end

module PrioQueue = Pqueue.MakeMinPoly(struct
  type 'a t = Prio.t * 'a
  let compare (p1, _) (p2, _) = Prio.compare p1 p2
end)

exception Value_not_found of string

let () =
  let start_time = Sys.time() in
  let pq = PrioQueue.create() in
  let ic = open_in "../8" in
  let rec read_lines ic acc =
  match input_line ic with
  | exception End_of_file -> acc
  | line ->
      let nums = line |> String.split_on_char ','
                      |> List.map (fun s -> int_of_string ) in
      match nums with
      | [x; y; z] -> read_lines ic ((x, y, z) :: acc)
      | _ -> failwith ("Invalid line: " ^ line)
  in
  let result = read_lines ic [] in

  let rec all_pair_combinations coords acc = match coords with
    | [] -> acc
    | hd :: tl -> all_pair_combinations tl ((List.map (fun x -> (hd, x)) tl) @ acc)
  in

  let square x = x * x in
  let distance (x1, y1, z1) (x2, y2, z2) = square (x1 - x2) + square (y1 - y2) + square (z1 - z2) in

  List.iter (fun x -> PrioQueue.add pq (distance (fst x) (snd x), x)) (all_pair_combinations result []);

  let get_x (x, _, _) = x in
  let uf = List.length result |> Union_find.create in

  let rec solve i n =
    let pair = match PrioQueue.pop_min pq with
      | Some (x, y) -> y
      | None -> raise (Value_not_found "Expected a pair")
    in
    if i = 1000 then begin
      Hashtbl.to_seq_keys uf.parent
      |> Seq.iter (fun x -> Union_find.find uf x |> ignore);

      Hashtbl.to_seq_values uf.parent
      |> Seq.fold_left (fun acc x -> (match Hashtbl.find_opt acc x with
      | Some v -> Hashtbl.replace acc x (v+1)
      | None -> Hashtbl.add acc x 1
      ); acc)
      (Hashtbl.create 100)
      |> Hashtbl.to_seq_values
      |> List.of_seq
      |> List.sort (fun x y -> -(compare x y))
      |> List.take 3
      |> List.fold_left (fun x y -> x * y) 1
      |> Printf.printf "Part 1: %d\n"
    end;

    if Union_find.find uf (fst pair) <> Union_find.find uf (snd pair) then begin
      Union_find.union uf (fst pair) (snd pair);
      if n = 2 then
        Printf.printf "Part 2: %d\n" ((fst pair |> get_x) * (snd pair |> get_x))
      else
        solve (i + 1) (n - 1)
    end
    else solve (i + 1) n
  in

  solve 0 (List.length result);
  Printf.printf "Execution time: %f seconds\n" (Sys.time() -. start_time);
```

## Day 9: Java

Execution time: 107ms

Today's puzzle had a pretty hard part 2, but upon inspecting the inputs you will
find that the points given are very nice and you can exploit the structure of
the shape formed. I based my solution off the shape of the input, which allows
me to achieve 30ms solves with Python. Some people may not agree with this
approach, but finding ways to exploit the input is part of these puzzles.

Part 1 is trivial, since you can just do an O(n^2) brute force, and actually
takes up most of the runtime. Part 2 is more interesting, and I used a ray
casting algorithm to detect if a point was in the overall polygon.

Before starting on part 2, I plotted out all the points, and joined the adjacent
points together, and found out that today's inputs has the following shape:

<img alt="image" src="https://github.com/user-attachments/assets/8ce047f2-3ec5-48e1-9652-acf77bdba3eb" />

This trivialises the problem a lot, observe that to obtain the maximum area, we
must choose one of those 2 points lying in the middle. Furthermore if we choose
the higher mid point, then we can only form rectangles with points above it,
otherwise it will cross the gap in the middle. Same thing for the lower mid
point.

So my solving strategy was to first find these 2 mid points, then iterate over
all points to the left of them, and try to form a valid rectangle. To detect if
a rectangle is valid, I check if the other 2 corners of the rectangle lie inside
the polygon, using a simple ray casting trick. If you shoot a beam to the left
of the point, and it intersects an odd number of vertical walls, then it is in
the polygon.

Along with some minor optimizations, I got my overall solution down to 30ms on
my machine! I did have one hiccup, where my area function was defined wrongly
(try and spot the mistake below), and I spent half an hour debugging my code
before realising.

```py
def area(p1, p2):
    return abs((p1[0] - p2[0] + 1) * (p1[1] - p2[1] + 1))
```

Here is my overall solution, while I did solve it with Java, the solution method
did not differ from my original Python solution, and it's just more verbose, so
I will just paste my Python solution here:

```py
inp = list(map(lambda x: tuple(map(int, x.split(","))), open("9").read().splitlines()))


def area(p1, p2):
    return (abs(p1[0] - p2[0]) + 1) * (abs(p1[1] - p2[1]) + 1)


max_area = 0

for i in range(len(inp)):
    for j in range(i + 1, len(inp)):
        max_area = max(max_area, area(inp[i], inp[j]))

print(f"Part 1: {max_area}")

vertical_lines = sorted(
    [sorted(inp[i : i + 2], key=lambda x: x[1]) for i in range(0, len(inp), 2)],
    key=lambda x: x[0][0],
)

horizontal_lines = [
    sorted(inp[i : i + 2], key=lambda x: x[0]) for i in range(1, len(inp) - 1, 2)
]


def in_poly(p):
    # Ray cast to left
    num_crossings = 0
    lows = set()
    highs = set()
    for line in vertical_lines:
        if line[0][0] >= p[0]:
            break
        if line[0][1] <= p[1] <= line[1][1]:
            if line[0][1] == p[1] and p[1] in highs:
                continue
            if line[1][1] == p[1] and p[1] in lows:
                continue
            lows.add(line[0][1])
            highs.add(line[1][1])
            num_crossings += 1

    return num_crossings % 2 == 1


longest_two = sorted(
    horizontal_lines, key=lambda x: abs(x[0][0] - x[1][0]), reverse=True
)
mid1 = (
    longest_two[0][0]
    if longest_two[0][0][0] > longest_two[0][1][0]
    else longest_two[0][1]
)
mid2 = (
    longest_two[1][0]
    if longest_two[1][0][0] > longest_two[1][1][0]
    else longest_two[1][1]
)

if mid1[1] < mid2[1]:
    mid1, mid2 = mid2, mid1

mid1_ylimit = 0
mid2_ylimit = 0
for i in horizontal_lines:
    if i[0][1] > mid1[1] and i[0][0] <= mid1[0] <= i[1][0]:
        mid1_ylimit = i[0][1]
    if i[0][1] < mid2[1] and i[0][0] <= mid2[0] <= i[1][0]:
        mid2_ylimit = i[0][1]


max_area = 0

for p in inp:
    m = None
    if p[0] >= mid1[0]:
        continue
    if mid1[1] <= p[1] <= mid1_ylimit:
        m = mid1
    elif mid2[1] <= p[1] <= mid2_ylimit:
        m = mid2
    if m is not None:
        p1, p2 = (p[0], m[1]), (m[0], p[1])
        if (a := area(m, p)) > max_area and in_poly(p1) and in_poly(p2):
            max_area = a
```

This was the rectangle my code found:
<img width="2089" height="1109" alt="image" src="https://github.com/user-attachments/assets/4292292d-2762-4062-9bc6-747bdd62d675" />

## Day 10: Python

Execution time: 1.04s

Day 10 was the hardest day out of all 12 days, which is why it is the Python
day. The second part required math I did not know, so I honestly did not solve
it until the last day, where it was required to get the last star. In the end, I
still don't fully understand the underlying math, I just googled a bit on how to
use z3 and plugged the problem into the optimizer to find the minimal solution.
It surprisingly only took like half an hour to figure out how to use z3 and
express the problem in it.

```py
from collections import deque
from z3 import Int, Optimize, Sum, sat

inp = list(map(str.split, open("10").read().splitlines()))

data = []
for line in inp:
    temp = []
    temp.append(sum(1 << i for i, v in enumerate(line[0][1:-1]) if v == "#"))
    temp += list(map(lambda x: tuple(map(int, x[1:-1].split(","))), line[1:-1]))
    temp.append(tuple(map(int, line[-1][1:-1].split(","))))

    data.append(tuple(temp))

part1 = 0
for line in data:
    goal = line[0]
    q = deque([(i, 0, 0) for i in line[1:-1]])
    visited = set()
    while (curr := q.popleft())[1] != goal:
        new = curr[1]
        switch = 0
        for i in curr[0]:
            switch += 1 << i
        new ^= switch

        if new in visited:
            continue
        visited.add(new)

        q.extend([(i, new, curr[2] + 1) for i in line[1:-1]])
    part1 += curr[2]

print(f"Part 1: {part1}")

part2 = 0

for line in data:
    ints = []

    s = Optimize()

    for i in range(len(line[1:-1])):
        ints.append(Int(f"v{i}"))
        s.add(ints[i] >= 0)

    for i in range(len(line[-1])):
        x = []
        for j in range(len(line[1:-1])):
            if i in line[j + 1]:
                x.append(ints[j])

        s.add(Sum(x) == line[-1][i])

    s.minimize(Sum(ints))

    if s.check() == sat:
        m = s.model()
        part2 += m.evaluate(Sum(ints)).as_long()
print(f"Part 2: {part2}")
```

## Day 11: JavaScript

Execution time: 52.2ms

Day 11 was so much easier than day 10, that it was kinda underwhelming. It's
basically just a depth first search with memoization.

```js
const fs = require("fs");

let memo = {};
let edges = {};

function num_paths(src, dst) {
  const key = `${src} ${dst}`;
  if (!(key in memo)) {
    ret = 0;

    edges[src].forEach((x) => {
      if (x === dst) ret += 1;
      else ret += num_paths(x, dst);
    });

    memo[key] = ret;
  }

  return memo[key];
}

fs.readFile("11", "utf8", (err, data) => {
  if (err) {
    console.log(err);
    return;
  }

  data.split("\n").forEach((line) => {
    if (line.length != 0) {
      let temp = line.split(":");
      edges[temp[0]] = temp[1].trim().split(" ");
    }
  });

  edges["out"] = [];

  console.log(`Part 1: ${num_paths("you", "out")}`);
  console.log(
    `Part 2: ${num_paths("svr", "fft") * num_paths("fft", "dac") * num_paths("dac", "out")}`,
  );
});
```

We can just define a memoized recursive function that finds the number of paths
from source to destination. Part 2 is just
`num_paths("svr", "fft") * num_paths("fft", "dac") * num_paths("dac", "out")`.

## Day 12: JLox

Execution time: 194ms

The last day presented us with an NP-Hard problem, which shocked many of us when
we initially saw it. We are given a set of 6 irregular shapes, each line in the
puzzle gives us the area of a grid and the number of each shape we must fit in
the grid. Then we have to find the number of grids where such an arrangement is
possible.

Luckily, the inputs were very nice, and in all cases, you can just check if the
grid is large enough to fit all the shapes laid out side by side without any
intersection between the shapes.

Since the solution is so simple, I decided to implement it in my own programming
language! I have been working on [JLox](https://github.com/mug1wara26/jlox) from
[Crafting Interpreters](https://craftinginterpreters.com/) and decided to add
enough native functions such as `stringSplit` and `read` to make the problem
solvable. I found it funny that although `stringSplit` returns an array, there
is no way to actually create arrays in my language yet. This program was run on
[this specific commit](https://github.com/mug1wara26/jlox/commit/1b2734ae614e250b7b086e1c185bdc9a1ae1047c)
in my JLox implementation.

```js
var inp = stringSplit(read("12"), "\n");
var part2 = 0;

for (var i = 30; i < arrayLength(inp); i = i + 1) {
  var line = stringSplit(inp[i], ":");
  var size = stringSplit(line[0], "x");

  var maxBlocks = floor(stringToNumber(size[0]) / 3) * floor(stringToNumber(size[1]) / 3);
  var total = 0;
  for (var j = 1; j < 7; j = j + 1)
    total = total + stringToNumber(stringSplit(line[1], " ")[j]);

  if (total <= maxBlocks)
    part2 = part2 + 1;
}

print part2;
```

## Conclusion

While I did manage to solve some puzzles in new languages I have not touched
before, I can't say that I have truly learned those languages, since I mostly
relied on a lot of Googling along the lines of "how to accomplish \<task\> in
\<language\>". That said it did give me a nice exposure to each of these
languages, and there will certainly be less friction if I decide to work on a
project in any of them in the future. For future years, I will just go back to
focusing on one single language.

I felt that this year's Advent of Code was far easier than previous years, and
not just because of the reduced days. Day 10 was the only puzzle that really
stood out as difficult, and in the end it can just be solved by expressing the
problem in z3. Nonetheless, I still had a lot of fun with AOC, and enjoyed
interacting with different communities throughout the 12 days. I really
appreciate Eric's work towards designing these puzzles every year for the past
11 years, and look forward to the next one!
